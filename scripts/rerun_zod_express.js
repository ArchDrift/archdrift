// Re-run analysis on zod and express with fixed logic
//
// NOTE: This script requires audit_targets/ directory with cloned repositories.
// If audit_targets/ is missing, this script will exit gracefully.
// Test results are preserved in test-results-backup/ for reference.

const { main, analyzeRepository } = require('./batch_analyze_standalone.js');
const fs = require('fs');
const path = require('path');

async function rerunSpecificRepos() {
    const batchDir = path.join(__dirname, '..', 'audit_targets', 'batch_1');
    const resultsDir = path.join(__dirname, '..', 'results', 'batch_1');
    
    // Check if audit_targets exists
    if (!fs.existsSync(batchDir)) {
        console.log('âš ï¸  audit_targets/batch_1 directory not found.');
        console.log('   This script requires cloned repositories to analyze.');
        console.log('   Test results are preserved in test-results-backup/ for reference.');
        process.exit(0);
    }
    
    const repos = ['zod', 'express'];
    const results = [];
    
    for (const repoName of repos) {
        const repoPath = path.join(batchDir, repoName);
        if (!fs.existsSync(repoPath)) {
            console.log(`âš ï¸  Skipping ${repoName} (not found)`);
            continue;
        }
        
        try {
            console.log(`\nðŸ“¦ Re-analyzing ${repoName} with fixed logic...`);
            const result = await analyzeRepository(repoPath, repoName);
            results.push(result);
            
            const repoOutputDir = path.join(resultsDir, repoName);
            if (!fs.existsSync(repoOutputDir)) {
                fs.mkdirSync(repoOutputDir, { recursive: true });
            }
            
            // Generate reports
            const integrityBar = 'â–ˆ'.repeat(Math.round((result.sii / 100) * 10)) + 
                                'â–‘'.repeat(10 - Math.round((result.sii / 100) * 10));
            
            const summary = `# ðŸ›¡ï¸ ArchDrift Structural Decay Analysis

**Workspace:** ${result.name}

---

## Structural Stability Signal: **${result.sii}**

[${integrityBar}]

### ðŸ§  Expert Diagnosis

Analysis complete. See full details below.

---

## Top Offenders

*Analysis details available in FULL_DETAILS.md*

---

## Pattern Breakdown

| Pattern | Count | Severity |
|---------|-------|----------|
| âš¡ N+1 Query | ${result.violations.nPlusOne} | ðŸŸ  High |
| ðŸ“¦ God Class | ${result.violations.godClass} | ðŸŸ¡ Medium |
| ðŸš« Layer Violation | ${result.violations.layer} | ðŸ”´ Critical |

ðŸ“‹ [View Full Details â†’](FULL_DETAILS.md)

---

Generated by ArchDrift v0.4
`;
            
            const weightedDebtDensity = result.productionLOC > 0 
                ? (result.weightedDebt / (result.productionLOC / 1000)).toFixed(2)
                : '0.00';
            
            let details = `# ðŸ“‹ ArchDrift Full Details

**Generated:** ${new Date().toLocaleString()}

This document contains a line-by-line breakdown of every violation detected.

---

## Weighted Debt Calculation

**Weighted Debt Density:** ${weightedDebtDensity} debt points per 1,000 lines of production code

**Severity Multipliers:**
- Layer Violations: Ã—10 (Fatal structural drift)
- N+1 Queries: Ã—2 (Core efficiency drift)
- God Classes: Ã—1 (Complexity drift)

**Production Code:** ${result.violations.layer + result.violations.nPlusOne + result.violations.godClass} violations (${result.weightedDebt} weighted debt) in ${result.productionLOC.toLocaleString()} LOC

**Total Files:** ${result.totalFiles} (${result.productionFiles} production)

---

## Violations Summary

- **Layer Violations:** ${result.violations.layer}
- **N+1 Queries:** ${result.violations.nPlusOne}
- **God Classes:** ${result.violations.godClass}

---

`;

            // Group violations by pattern and file
            const violationsByPattern = {};
            result.allRawIssues.forEach(issue => {
                if (!violationsByPattern[issue.pattern]) {
                    violationsByPattern[issue.pattern] = {};
                }
                const filePath = issue.filePath || 'unknown';
                if (!violationsByPattern[issue.pattern][filePath]) {
                    violationsByPattern[issue.pattern][filePath] = [];
                }
                violationsByPattern[issue.pattern][filePath].push(issue);
            });
            
            // Generate detailed violations
            const patternOrder = ['God Class', 'N+1 Query', 'Layer Violation'];
            patternOrder.forEach(pattern => {
                if (violationsByPattern[pattern]) {
                    const emoji = pattern === 'God Class' ? 'ðŸ“¦' : pattern === 'N+1 Query' ? 'âš¡' : 'ðŸš«';
                    details += `## ${emoji} ${pattern}\n\n`;
                    
                    const files = Object.keys(violationsByPattern[pattern]).sort();
                    files.forEach(filePath => {
                        const relativePath = path.relative(repoPath, filePath).replace(/\\/g, '/');
                        details += `### \`${relativePath}\`\n\n`;
                        violationsByPattern[pattern][filePath].sort((a, b) => a.line - b.line).forEach(issue => {
                            details += `- **Line ${issue.line}:** ${issue.message}\n`;
                        });
                        details += `\n`;
                    });
                }
            });
            
            details += `---\n\nGenerated by ArchDrift v0.4\n`;
            
            fs.writeFileSync(path.join(repoOutputDir, 'SUMMARY.md'), summary);
            fs.writeFileSync(path.join(repoOutputDir, 'FULL_DETAILS.md'), details);
            
            console.log(`  âœ… ${repoName}: SII ${result.sii}% | Files: ${result.productionFiles} | LOC: ${result.productionLOC.toLocaleString()} | Debt: ${result.weightedDebt}`);
        } catch (error) {
            console.error(`âŒ Error analyzing ${repoName}:`, error.message);
        }
    }
    
    console.log(`\nâœ… Re-analysis complete!`);
    console.log(`\nResults:`);
    results.forEach(r => {
        console.log(`  ${r.name}: ${r.sii}% (${r.productionFiles} files, ${r.weightedDebt} debt)`);
    });
}

if (require.main === module) {
    rerunSpecificRepos().catch(console.error);
}

module.exports = { rerunSpecificRepos };
