# Chat: Chat 3 from ebf1d29318bd9e8490b5e970ffca225d

**Source:** ebf1d29318bd9e8490b5e970ffca225d/aiService.prompts
**Messages:** 1
**Recovered:** 2026-01-03T19:39:53.674Z

---

## unknown

follow this: Great. Here‚Äôs the **precise spec** for the next rule to give your coder.

***

## Layer Integrity Rule ‚Äì Technical Specification

### Goal

Add a third analysis rule to DriftGuard that detects **forbidden dependencies between architectural layers** based on file paths and import targets.

This is the first explicitly **architectural** invariant:  
> ‚ÄúCertain layers must not depend on others.‚Äù

No configuration in v0.2; use a **convention‚Äëover‚Äëconfiguration** model.

***

## 1. Layer model (convention)

We define three logical layers, inferred from directory names in the file path:

- **API layer** (outermost, delivery / presentation):
  - Any file whose path contains one of:
    - `/api/`
    - `/presentation/`
    - `/controllers/`
- **Domain layer** (core business logic):
  - Any file whose path contains one of:
    - `/domain/`
    - `/core/`
    - `/usecases/`
- **Infra layer** (infrastructure, persistence, external systems):
  - Any file whose path contains one of:
    - `/infra/`
    - `/infrastructure/`
    - `/persistence/`
    - `/adapters/`

If a file‚Äôs path matches multiple patterns (edge case), prefer the **most specific** based on this priority:

- domain > api > infra (but you can choose any deterministic priority; just document it).

If a file matches **none** of the patterns, treat it as **‚Äúunclassified‚Äù** and **do not apply** layer rules to it in v0.2.

***

## 2. Allowed vs forbidden dependencies

For v0.2, hard‚Äëcode a simple, opinionated dependency graph:

- From **API**:
  - API ‚Üí Domain: **allowed**
  - API ‚Üí Infra: **allowed**
- From **Domain**:
  - Domain ‚Üí Infra: **allowed** (you can revisit later)
  - Domain ‚Üí API: **forbidden**
- From **Infra**:
  - Infra ‚Üí Domain: **forbidden**
  - Infra ‚Üí API: **forbidden**

Unclassified ‚Üí anything: **ignored** (no checks).

This gives a small number of forbidden edges to check:

- `domain` importing from `api`
- `infra` importing from `api`
- `infra` importing from `domain`

***

## 3. What counts as a ‚Äúdependency‚Äù

Within a file, you must parse **import/require** forms for supported languages:

- JS/TS:
  - `import X from '...';`
  - `import {A, B} from '...';`
  - `const X = require('...');`
- Python:
  - `import package.module`
  - `from package.module import X`
- Java:
  - `import com.mycompany.domain.*;` etc.
- Go:
  - `import "myorg/project/domain/foo"`

For v0.2, you don‚Äôt need a full parser; it‚Äôs acceptable to:

- Use regex or a lightweight parser to:
  - Identify import/require lines.
  - Extract the target module string / path segment.

The **target path resolution** can be heuristic:

- For relative imports (`../domain/foo`, `./infra/db`), resolve against the current file‚Äôs directory to get a normalized path string and then map it to a layer via the same rules as the source file.
- For absolute/aliased imports (`@app/domain/foo`, `myorg/project/infra/db`), just run the layer‚Äëpattern matching over the import string itself.

You do **not** need full module resolution or TS path mapping in v0.2‚Äîjust pattern matching on strings.

***

## 4. Analyzer behavior

In `analyzer.ts`, add a new function conceptually like:

> Input:
> - Full path of the source file.
> - Full text of the source file.
>
> Output:
> - Array of `LayerViolation` objects:
>   - `sourceLayer` (api | domain | infra)
>   - `targetLayer` (api | domain | infra)
>   - `line`, `column`
>   - `importText` (the import line snippet)

Algorithm:

1. Compute `sourceLayer` from the file path, using the directory patterns.
   - If `unclassified`, return empty array.
2. Scan all lines for import forms (per language).
3. For each import:
   - Extract `targetModule` string.
   - Map `targetModule` (or resolved path) to `targetLayer` using the same patterns.
   - If `targetLayer` is `unclassified`, skip.
   - Check `(sourceLayer, targetLayer)` against the forbidden list.
   - If forbidden, add a `LayerViolation` for that line.

Performance: keep this linear in number of lines; this must be cheap enough to run on open/save like the other rules.

***

## 5. VS Code wiring

In `extension.ts`:

- After running the existing rules (God Class + N+1), also call the new layer analysis.
- For each `LayerViolation`:
  - Create a **Diagnostic** with:
    - Severity: **Error** or **Warning**‚Äîyou decide, but it should feel **more serious** than N+1 (which is purely performance).
    - Range: the import line.
    - Message template like:

      > `Layer violation: {sourceLayer} module importing from {targetLayer} ("{importText}"). According to DriftGuard‚Äôs default rules, {sourceLayer} must not depend on {targetLayer}.`

- Include these diagnostics in the same collection as the others so they appear:
  - Underlined in the editor.
  - In the Problems panel.

### Status bar priority

Update status bar logic:

- If there is at least one **LayerViolation** for the active file:
  - Show something like:

    > `üö´ DriftGuard: Layer violations (N)`

- Else if oversized:
  - `üö® DriftGuard: Oversized (N lines)`
- Else if N+1:
  - `‚ö† DriftGuard: N+1 hotspots (K)`
- Else:
  - `‚úÖ DriftGuard: Clean`

This makes the architectural rule visually dominant.

***

## 6. UX expectations

From a developer‚Äôs point of view, with v0.2 installed:

- Open a `domain` file that imports from `api`:
  - They immediately see:
    - The import line underlined.
    - Hover message explaining the layer violation.
    - A red/serious status bar item highlighting layer violations.
- Open an `infra` file importing from `api` or `domain`:
  - Same treatment.
- Open files outside `api/domain/infra` paths:
  - No layer checks run; only God Class and N+1 apply.

***

## 7. Future configurability (for the coder‚Äôs awareness)

Tell the coder this is **deliberately hard‚Äëcoded for now**, but should be implemented in a way that later allows:

- Custom layer patterns (user‚Äësupplied regex / glob).
- Custom allowed edges.

That means:

- Keep the layer mapping and allowed edge logic **isolated** in small functions or a small config object in code, not scattered.

***

Hand this to your engineer as:  

> ‚ÄúImplement this third rule into the existing `analyzer.ts` / `extension.ts` structure. Keep performance in mind; prioritize correctness of the layer mapping and clear diagnostics over completeness of language coverage.‚Äù

[1](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/images/87529099/179a90ce-f98a-4b6c-aa81-9bb0e122775f/image.jpg)
[2](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/images/87529099/334b9707-9563-494a-90ce-7d8c710b1115/image.jpg)
[3](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/images/87529099/534fbf37-1d0c-4a38-b7b8-0a703b335876/image.jpg)
[4](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/images/87529099/93fe2ebb-9154-45da-a6e8-20f65070e863/image.jpg)
[5](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/images/87529099/6306caa0-e344-4c0d-a080-a34ec6d1f599/image.jpg)
[6](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/images/87529099/fdf3ea8d-9dcb-422c-8eca-63e372f5df7d/image.jpg)
[7](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/images/87529099/f3461056-f67b-435a-8022-d4e6ab2674e1/image.jpg)
[8](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/images/87529099/6b6a8781-f4e9-4533-89b1-a39f38ebb1cc/image.jpg)
[9](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/images/87529099/06017215-188d-4843-84cc-42505db1221b/image.jpg)
[10](https://ppl-ai-file-upload.s3.amazonaws.com/web/direct-files/attachments/images/87529099/9abf2fc1-215d-480e-90d7-8f94a3b7c06c/image.jpg)

---

