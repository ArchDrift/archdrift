# Chat: Chat 4 from ebf1d29318bd9e8490b5e970ffca225d

**Source:** ebf1d29318bd9e8490b5e970ffca225d/aiService.prompts
**Messages:** 1
**Recovered:** 2026-01-03T19:39:53.676Z

---

## unknown

follow this: Great. Hereâ€™s the **precise spec** for the next rule to give your coder.

***

## Layer Integrity Rule â€“ Technical Specification

### Goal

Add a third analysis rule to DriftGuard that detects **forbidden dependencies between architectural layers** based on file paths and import targets.

This is the first explicitly **architectural** invariant:  
> â€œCertain layers must not depend on others.â€

No configuration in v0.2; use a **conventionâ€‘overâ€‘configuration** model.

***

## 1. Layer model (convention)

We define three logical layers, inferred from directory names in the file path:

- **API layer** (outermost, delivery / presentation):
  - Any file whose path contains one of:
    - `/api/`
    - `/presentation/`
    - `/controllers/`
- **Domain layer** (core business logic):
  - Any file whose path contains one of:
    - `/domain/`
    - `/core/`
    - `/usecases/`
- **Infra layer** (infrastructure, persistence, external systems):
  - Any file whose path contains one of:
    - `/infra/`
    - `/infrastructure/`
    - `/persistence/`
    - `/adapters/`

If a fileâ€™s path matches multiple patterns (edge case), prefer the **most specific** based on this priority:

- domain > api > infra (but you can choose any deterministic priority; just document it).

If a file matches **none** of the patterns, treat it as **â€œunclassifiedâ€** and **do not apply** layer rules to it in v0.2.

***

## 2. Allowed vs forbidden dependencies

For v0.2, hardâ€‘code a simple, opinionated dependency graph:

- From **API**:
  - API â†’ Domain: **allowed**
  - API â†’ Infra: **allowed**
- From **Domain**:
  - Domain â†’ Infra: **allowed** (you can revisit later)
  - Domain â†’ API: **forbidden**
- From **Infra**:
  - Infra â†’ Domain: **forbidden**
  - Infra â†’ API: **forbidden**

Unclassified â†’ anything: **ignored** (no checks).

This gives a small number of forbidden edges to check:

- `domain` importing from `api`
- `infra` importing from `api`
- `infra` importing from `domain`

***

## 3. What counts as a â€œdependencyâ€

Within a file, you must parse **import/require** forms for supported languages:

- JS/TS:
  - `import X from '...';`
  - `import {A, B} from '...';`
  - `const X = require('...');`
- Python:
  - `import package.module`
  - `from package.module import X`
- Java:
  - `import com.mycompany.domain.*;` etc.
- Go:
  - `import "myorg/project/domain/foo"`

For v0.2, you donâ€™t need a full parser; itâ€™s acceptable to:

- Use regex or a lightweight parser to:
  - Identify import/require lines.
  - Extract the target module string / path segment.

The **target path resolution** can be heuristic:

- For relative imports (`../domain/foo`, `./infra/db`), resolve against the current fileâ€™s directory to get a normalized path string and then map it to a layer via the same rules as the source file.
- For absolute/aliased imports (`@app/domain/foo`, `myorg/project/infra/db`), just run the layerâ€‘pattern matching over the import string itself.

You do **not** need full module resolution or TS path mapping in v0.2â€”just pattern matching on strings.

***

## 4. Analyzer behavior

In `analyzer.ts`, add a new function conceptually like:

> Input:
> - Full path of the source file.
> - Full text of the source file.
>
> Output:
> - Array of `LayerViolation` objects:
>   - `sourceLayer` (api | domain | infra)
>   - `targetLayer` (api | domain | infra)
>   - `line`, `column`
>   - `importText` (the import line snippet)

Algorithm:

1. Compute `sourceLayer` from the file path, using the directory patterns.
   - If `unclassified`, return empty array.
2. Scan all lines for import forms (per language).
3. For each import:
   - Extract `targetModule` string.
   - Map `targetModule` (or resolved path) to `targetLayer` using the same patterns.
   - If `targetLayer` is `unclassified`, skip.
   - Check `(sourceLayer, targetLayer)` against the forbidden list.
   - If forbidden, add a `LayerViolation` for that line.

Performance: keep this linear in number of lines; this must be cheap enough to run on open/save like the other rules.

***

## 5. VS Code wiring

In `extension.ts`:

- After running the existing rules (God Class + N+1), also call the new layer analysis.
- For each `LayerViolation`:
  - Create a **Diagnostic** with:
    - Severity: **Error** or **Warning**â€”you decide, but it should feel **more serious** than N+1 (which is purely performance).
    - Range: the import line.
    - Message template like:

      > `Layer violation: {sourceLayer} module importing from {targetLayer} ("{importText}"). According to DriftGuardâ€™s default rules, {sourceLayer} must not depend on {targetLayer}.`

- Include these diagnostics in the same collection as the others so they appear:
  - Underlined in the editor.
  - In the Problems panel.

### Status bar priority

Update status bar logic:

- If there is at least one **LayerViolation** for the active file:
  - Show something like:

    > `ğŸš« DriftGuard: Layer violations (N)`

- Else if oversized:
  - `ğŸš¨ DriftGuard: Oversized (N lines)`
- Else if N+1:
  - `âš  DriftGuard: N+1 hotspots (K)`
- Else:
  - `âœ… DriftGuard: Clean`

This makes the architectural rule visually dominant.

***

## 6. UX expectations

From a developerâ€™s point of view, with v0.2 installed:

- Open a `domain` file that imports from `api`:
  - They immediately see:
    - The import line underlined.
    - Hover message explaining the layer violation.
    - A red/serious status bar item highlighting layer violations.
- Open an `infra` file importing from `api` or `domain`:
  - Same treatment.
- Open files outside `api/domain/infra` paths:
  - No layer checks run; only God Class and N+1 apply.

***

## 7. Future configurability (for the coderâ€™s awareness)

Tell the coder this is **deliberately hardâ€‘coded for now**, but should be implemented in a way that later allows:

- Custom layer patterns (userâ€‘supplied regex / glob).
- Custom allowed edges.

That means:

- Keep the layer mapping and allowed edge logic **isolated** in small functions or a small config object in code, not scattered.

***

Hand this to your engineer as:  

> â€œImplement this third rule into the existing `analyzer.ts` / `extension.ts` structure. Keep performance in mind; prioritize correctness of the layer mapping and clear diagnostics over completeness of language coverage.â€


---

